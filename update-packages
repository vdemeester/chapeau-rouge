#!/usr/bin/env nix-shell
#! nix-shell -i bash -p bash git nix-update jq

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Get the script directory
SCRIPTPATH="$( cd "$(dirname "$0")" ; pwd -P )"
cd "$SCRIPTPATH"

# Function to print colored messages
info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Get all packages from the flake
get_all_packages() {
    nix eval --json '.#packages.x86_64-linux' --apply 'builtins.attrNames' 2>/dev/null | jq -r '.[]'
}

# Get packages that are tracked via git (have JSON files in repos/)
get_git_packages() {
    local git_packages=()
    for json_file in repos/*.json; do
        if [ -f "$json_file" ]; then
            # Extract package name from filename (e.g., deptree-main.json -> deptree)
            local pkg_name=$(basename "$json_file" | sed 's/-[^-]*\.json$//')
            git_packages+=("$pkg_name")
        fi
    done
    echo "${git_packages[@]}"
}

# Check if a package has a version suffix (e.g., opm_1_60, operator-sdk_1_41)
# These versioned variants should not be updated by nix-update
has_version_suffix() {
    local package=$1
    # Match patterns like _X_Y or _X at the end (version numbers)
    if [[ "$package" =~ _[0-9]+(_[0-9]+)?$ ]]; then
        return 0
    fi
    return 1
}

# Check if a package is git-tracked (either by name or by using a git-tracked repo JSON)
is_git_package() {
    local package=$1
    local git_packages=($(get_git_packages))

    # Check if package name matches a git repo name
    for git_pkg in "${git_packages[@]}"; do
        if [ "$git_pkg" = "$package" ]; then
            return 0
        fi
    done

    # Check if the package's nix file imports any git-tracked repo JSON
    local pkg_file="packages/${package}.nix"
    if [ -f "$pkg_file" ]; then
        for json_file in repos/*.json; do
            if [ -f "$json_file" ]; then
                local json_basename=$(basename "$json_file")
                if grep -q "$json_basename" "$pkg_file" 2>/dev/null; then
                    return 0
                fi
            fi
        done
    fi

    return 1
}

# Check if a package has versioned variants in the flake
# (e.g., opm has opm_1_60, opm_1_61, so opm should be skipped)
has_versioned_variants() {
    local package=$1
    local all_packages=($(get_all_packages))

    for pkg in "${all_packages[@]}"; do
        # Check if there's a package named ${package}_X_Y or ${package}_X
        if [[ "$pkg" =~ ^${package}_[0-9]+(_[0-9]+)?$ ]]; then
            return 0
        fi
    done
    return 1
}

# Check if a package should be skipped for nix-update
should_skip_nix_update() {
    local package=$1

    # Skip git-tracked packages
    if is_git_package "$package"; then
        return 0
    fi

    # Skip versioned variants (e.g., opm_1_60, operator-sdk_1_41)
    if has_version_suffix "$package"; then
        return 0
    fi

    # Skip base packages that have versioned variants
    # (updating opm would modify opm_1_61 since opm = opm_1_61)
    if has_versioned_variants "$package"; then
        return 0
    fi

    return 1
}

# Function to update packages using nix-update
update_with_nix_update() {
    local package=$1
    info "Updating $package with nix-update..."

    if nix-update --flake --commit "$package"; then
        info "Successfully updated $package"
        return 0
    else
        warn "Failed to update $package with nix-update"
        return 1
    fi
}

# Function to update packages from git repos
update_from_git() {
    local specific_packages=("$@")
    local git_packages=($(get_git_packages))

    if [ ${#git_packages[@]} -eq 0 ]; then
        info "No git-tracked packages found"
        return 0
    fi

    info "Updating packages from git repositories: ${git_packages[*]}..."

    if ./repos/update; then
        info "Successfully updated git-tracked packages"

        # Check if there are changes to commit
        if ! git diff --exit-code repos/ > /dev/null 2>&1; then
            info "Changes detected in repos/, committing..."
            git add repos/
            git commit -m "Auto-update packages" -- repos/
        else
            info "No changes in git-tracked packages"
        fi
        return 0
    else
        error "Failed to update git-tracked packages"
        return 1
    fi
}

# Main update logic
main() {
    local packages_to_update=("$@")
    local all_packages=($(get_all_packages))
    local git_packages=($(get_git_packages))

    info "Found packages in flake: ${all_packages[*]}"
    info "Git-tracked packages: ${git_packages[*]}"

    # If no packages specified, update all
    if [ ${#packages_to_update[@]} -eq 0 ]; then
        info "No specific packages specified, updating all packages..."

        # First, update git-tracked packages
        if [ ${#git_packages[@]} -gt 0 ]; then
            update_from_git
        fi

        # Then update packages that can use nix-update
        for package in "${all_packages[@]}"; do
            if should_skip_nix_update "$package"; then
                info "Skipping $package (git-tracked or versioned variant)"
            else
                info "Updating $package with nix-update..."
                update_with_nix_update "$package" || true
            fi
        done

        info "All package updates completed"
    else
        # Update specific packages
        local git_packages_to_update=()
        local nix_packages_to_update=()

        for package in "${packages_to_update[@]}"; do
            # Check if package exists in flake
            local package_exists=false
            for flake_pkg in "${all_packages[@]}"; do
                if [ "$flake_pkg" = "$package" ]; then
                    package_exists=true
                    break
                fi
            done

            if [ "$package_exists" = false ]; then
                error "Unknown package: $package"
                error "Available packages: ${all_packages[*]}"
                exit 1
            fi

            # Categorize package
            if is_git_package "$package"; then
                git_packages_to_update+=("$package")
            elif has_version_suffix "$package"; then
                warn "Skipping $package (versioned variant, update the base package instead)"
            else
                nix_packages_to_update+=("$package")
            fi
        done

        # Update git-tracked packages
        if [ ${#git_packages_to_update[@]} -gt 0 ]; then
            info "Updating git-tracked packages: ${git_packages_to_update[*]}"
            update_from_git "${git_packages_to_update[@]}"
        fi

        # Update nix-update packages
        for package in "${nix_packages_to_update[@]}"; do
            update_with_nix_update "$package"
        done
    fi
}

# Run main function with all arguments
main "$@"
